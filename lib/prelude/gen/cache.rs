use super::*;
use std::convert::TryFrom;
use std::borrow::Cow;

/** A wrapper around GenMove to cache the moves generated by an iterator.
    You should consider using this if you wish to re-use a `GenMoves`-iterator.
**/
#[derive(Clone)]
pub struct CacheMoves<I: Iterator<Item = Move>> {
    iterator: std::iter::Fuse<I>,
    done: bool,
    pub cache: Vec<Move>, // TODO: use Cow for iterator clone?
}

/** A wrapper around GenMove to cache the moves generated by an iterator.
    You should consider using this if you wish to re-use a `GenMoves`-iterator.
**/
#[derive(Clone)]
pub struct CacheMovesBoards<'a, I: Iterator<Item = Move>> {
    iterator: std::iter::Fuse<I>,
    done: bool,
    pub cache: Vec<Move>, // TODO: use Cow for iterator clone?
    pub cache_boards: Vec<(Board, Option<Board>)>,

    // Used for board generation
    pub game: &'a Game,
    pub partial_game: &'a PartialGame<'a>,
}

impl<'a, G: GenMoves<'a>> TryFrom<(G, &'a Game, &'a PartialGame<'a>)> for CacheMoves<G::Iter> {
    type Error = ();
    /**
        Creates a new CacheMoves iterator out of a `GenMoves`-implementor and the required information for `generate_moves`.
        You may use this with a PiecePosition or a Board instance.
    **/
    fn try_from(
        (generator, game, partial_game): (G, &'a Game, &'a PartialGame<'a>),
    ) -> Result<Self, Self::Error> {
        match generator.generate_moves(game, partial_game) {
            Some(iter) => Ok(Self {
                iterator: iter.fuse(),
                cache: vec![],
                done: false,
            }),
            None => Err(()),
        }
    }
}

impl<I: Iterator<Item = Move>> CacheMoves<I> {
    pub fn new(iter: I) -> Self {
        Self {
            iterator: iter.fuse(),
            cache: vec![],
            done: false,
        }
    }

    pub fn from_raw_parts(iterator: std::iter::Fuse<I>, cache: Vec<Move>, done: bool) -> Self {
        Self {
            iterator,
            cache,
            done,
        }
    }

    /**
        Validates a move (sees if the move is yielded by the underlying iterator) by looking through the cached moves. This function will not query
        the move iterator.

        Since not every move is looked through, if this function returns false,
        then it doesn't mean that the move is invalid. For a more thorough but expensive move
        validation function, you should use `validate_move`.
    **/
    pub fn validate_move_cached(&self, mv: &Move) -> bool {
        for cached_mv in self.cache.iter() {
            if cached_mv == mv {
                return true;
            }
        }

        false
    }

    /**
        Validates a move (sees if the move is yielded by the underlying iterator) by first traversing the cached moves and then consuming the iterator
        until the move is found. You should prefer using `G::validate_move` over this function
        for its potential speed benefit, unless you want to validate many moves from the same `CacheMoves` instance.
    **/
    pub fn validate_move(&mut self, mv: &Move) -> bool {
        if self.validate_move_cached(mv) {
            return true;
        }

        while let Some(m) = self.next() {
            if m == *mv {
                return true;
            }
        }

        false
    }

    /**
        Returns the n-th move from the cache. This function will not query the move iterator.
        You should use `get` if you also wish to query the move iterator.

        Returns `None` if the move isn't in the cache.
    **/
    pub fn get_cached(&mut self, n: usize) -> Option<Move> {
        if n < self.cache.len() {
            Some(self.cache[n])
        } else {
            None
        }
    }

    /**
        Returns the n-th move of the iterator. If that move already lies in the cache, then it is queried from the cache. Otherwise, the iterator is consumed up to the n-th move, if found.

        Returns `None` if the move is neither in the cache, nor could the iterator yield enough moves.
    **/
    pub fn get(&mut self, mut n: usize) -> Option<Move> {
        if n < self.cache.len() {
            Some(self.cache[n])
        } else {
            n -= self.cache.len();

            while let Some(m) = self.next() {
                if n == 0 {
                    return Some(m);
                }
                n -= 1;
            }

            None
        }
    }

    /**
        Returns true if the underlying iterator got fully consumed.
    **/
    pub fn done(&self) -> bool {
        self.done
    }

    /**
        Returns the underlying raw parts. Only use this if you know what you're doing!
    **/
    pub fn into_raw_parts(self) -> (std::iter::Fuse<I>, Vec<Move>, bool) {
        (self.iterator, self.cache, self.done)
    }

    /**
        Returns the length of the cache; this is only equal to the number of moves if
        the underlying iterator got fully consumed.
    **/
    pub fn cache_len(&self) -> usize {
        self.cache.len()
    }

    /**
        Consumes the entirety of the underlying iterator, putting all of the moves in the cache.
    **/
    pub fn consume(&mut self) {
        while let Some(_m) = self.next() {
            // Noop
        }
    }
}

impl<'a, I: Iterator<Item = Move>> Iterator for CacheMoves<I> {
    type Item = Move;

    /**
        Yields the next move, if present, and caches it.
    **/
    fn next(&mut self) -> Option<Move> {
        if self.done {
            None
        } else {
            match self.iterator.next() {
                Some(m) => {
                    self.cache.push(m);
                    Some(m)
                }
                None => {
                    self.done = true;
                    None
                }
            }
        }
    }
}

impl<'a, G: GenMoves<'a>> TryFrom<(G, &'a Game, &'a PartialGame<'a>)> for CacheMovesBoards<'a, G::Iter> {
    type Error = ();
    /**
        Creates a new CacheMovesBoards iterator out of a `GenMoves`-implementor and the required information for `generate_moves`.
        You may use this with a PiecePosition or a Board instance.
    **/
    fn try_from(
        (generator, game, partial_game): (G, &'a Game, &'a PartialGame<'a>),
    ) -> Result<Self, Self::Error> {
        match generator.generate_moves(game, partial_game) {
            Some(iter) => Ok(Self {
                iterator: iter.fuse(),
                cache: vec![],
                cache_boards: vec![],
                done: false,
                game,
                partial_game,
            }),
            None => Err(()),
        }
    }
}

impl<'a, I: Iterator<Item = Move>> CacheMovesBoards<'a, I> {
    pub fn new(iter: I, game: &'a Game, partial_game: &'a PartialGame<'a>) -> Self {
        Self {
            iterator: iter.fuse(),
            cache: vec![],
            cache_boards: vec![],
            done: false,
            game,
            partial_game,
        }
    }

    pub fn from_raw_parts(
        (iterator, cache, cache_boards, done, game, partial_game): (
            std::iter::Fuse<I>,
            Vec<Move>,
            Vec<(Board, Option<Board>)>,
            bool,
            &'a Game,
            &'a PartialGame<'a>,
        )
    ) -> Self {
        Self {
            iterator,
            cache,
            cache_boards,
            done,
            game,
            partial_game
        }
    }

    /**
        Validates a move (sees if the move is yielded by the underlying iterator) by looking through the cached moves. This function will not query
        the move iterator.

        Since not every move is looked through, if this function returns false,
        then it doesn't mean that the move is invalid. For a more thorough but expensive move
        validation function, you should use `validate_move`.
    **/
    pub fn validate_move_cached(&self, mv: &Move) -> bool {
        for cached_mv in self.cache.iter() {
            if cached_mv == mv {
                return true;
            }
        }

        false
    }

    /**
        Validates a move (sees if the move is yielded by the underlying iterator) by first traversing the cached moves and then consuming the iterator
        until the move is found. You should prefer using `G::validate_move` over this function
        for its potential speed benefit, unless you want to validate many moves from the same `CacheMovesBoards` instance.
    **/
    pub fn validate_move(&mut self, mv: &Move) -> bool {
        if self.validate_move_cached(mv) {
            return true;
        }

        while let Some(m) = self.next() {
            if m == *mv {
                return true;
            }
        }

        false
    }

    /**
        Returns the n-th move from the cache. This function will not query the move iterator.
        You should use `get` if you also wish to query the move iterator.

        Returns `None` if the move isn't in the cache.
    **/
    pub fn get_cached(&mut self, n: usize) -> Option<Move> {
        if n < self.cache.len() {
            Some(self.cache[n])
        } else {
            None
        }
    }

    /**
        Returns the n-th move of the iterator. If that move already lies in the cache, then it is queried from the cache. Otherwise, the iterator is consumed up to the n-th move, if found.

        Returns `None` if the move is neither in the cache, nor could the iterator yield enough moves.
    **/
    pub fn get(&mut self, mut n: usize) -> Option<Move> {
        if n < self.cache.len() {
            Some(self.cache[n])
        } else {
            n -= self.cache.len();

            while let Some(m) = self.next() {
                if n == 0 {
                    return Some(m);
                }
                n -= 1;
            }

            None
        }
    }

    /**
        Returns the n-th board m-uple - corresponding to the boards generated by the n-th move - from the cache, or None if the index is outside of the cache.
    **/
    pub fn get_cached_board(&self, n: usize) -> Option<(Cow<'_, Board>, Cow<'_, Option<Board>>)> {
        if n < self.cache.len() {
            Some((Cow::Borrowed(&self.cache_boards[n].0), Cow::Borrowed(&self.cache_boards[n].1)))
        } else {
            None
        }
    }

    /**
        Returns the n-th board m-uple; it first looks if it is already in the cache.
        Otherwise, the iterator is consumed up to the n-th move and its corresponding boards are returned.
    **/
    pub fn get_board(&mut self, mut n: usize) -> Option<(Cow<'_, Board>, Cow<'_, Option<Board>>)> {
        if n < self.cache.len() {
            Some((Cow::Borrowed(&self.cache_boards[n].0), Cow::Borrowed(&self.cache_boards[n].1)))
        } else {
            n -= self.cache.len();

            while let Some(_m) = self.next() {
                if n == 0 {
                    let c = &self.cache_boards[self.cache_boards.len() - 1];
                    return Some((Cow::Borrowed(&c.0), Cow::Borrowed(&c.1)));
                }
                n -= 1;
            }

            None
        }
    }

    /**
        Returns true if the underlying iterator got fully consumed.
    **/
    pub fn done(&self) -> bool {
        self.done
    }

    /**
        Returns the underlying raw parts. Only use this if you know what you're doing!
    **/
    pub fn into_raw_parts(self) -> (std::iter::Fuse<I>, Vec<Move>, Vec<(Board, Option<Board>)>, bool, &'a Game, &'a PartialGame<'a>) {
        (self.iterator, self.cache, self.cache_boards, self.done, self.game, self.partial_game)
    }

    /**
        Returns the length of the cache; this is only equal to the number of moves if
        the underlying iterator got fully consumed.
    **/
    pub fn cache_len(&self) -> usize {
        self.cache.len()
    }

    /**
        Consumes the entirety of the underlying iterator, putting all of the moves in the cache.
    **/
    pub fn consume(&mut self) {
        while let Some(_m) = self.next() {
            // Noop
        }
    }
}

impl<'a, I: Iterator<Item = Move>> Iterator for CacheMovesBoards<'a, I> {
    type Item = Move;

    /**
        Yields the next move, if present, and caches it.
    **/
    fn next(&mut self) -> Option<Move> {
        if self.done {
            None
        } else {
            match self.iterator.next() {
                Some(m) => {
                    self.cache.push(m);

                    if m.is_jump() {
                        let source_board = m.generate_source_board(self.game, self.partial_game)?;
                        let target_board = m.generate_target_board(self.game, self.partial_game)?;
                        self.cache_boards.push((source_board, Some(target_board)));
                    } else {
                        let source_board = m.generate_source_board(self.game, self.partial_game)?;
                        self.cache_boards.push((source_board, None));
                    }

                    Some(m)
                }
                None => {
                    self.done = true;
                    None
                }
            }
        }
    }
}
