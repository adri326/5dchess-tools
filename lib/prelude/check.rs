use super::*;
use std::collections::HashMap;

/**
    Generates idle boards. Idle boards are defined as such:
    - take the present, active boards owned by the current player
    - copy them and add them to the end of their timeline, effectively passing them to the opponent
**/
pub fn generate_idle_boards<'a>(
    game: &'a Game,
    partial_game: &'a PartialGame<'a>,
) -> Option<PartialGame<'a>> {
    let mut new_partial_game = PartialGame::new(HashMap::new(), partial_game.info.clone(), None);

    for board in partial_game.own_boards(game) {
        if board.t() == partial_game.info.present {
            let mut n_board = board.clone();
            n_board.t += 1;
            n_board.en_passant = None;
            new_partial_game.insert(n_board);
            new_partial_game
                .info
                .get_timeline_mut(board.l())?
                .last_board += 1;
        }
    }

    new_partial_game.parent = Some(partial_game);
    Some(new_partial_game)
}

/**
    Checks whether or not the opponent can currently take the current player's king.
    This function can be used to verify that a position is in check by passing it the IDLE boards, generated by `generate_idle_boards`.
    It differs from `is_illegal`, as it looks at the *opponent's* moves, instead of the *current player's* moves.
**/
pub fn is_in_check<'a>(game: &'a Game, partial_game: &'a PartialGame<'a>) -> Option<bool> {
    for board in partial_game.opponent_boards(game) {
        for mv in board.generate_moves_flag(game, partial_game, GenMovesFlag::Check)? {
            if let Some(piece) = mv.to.0 {
                if piece.is_royal() && piece.white == partial_game.info.active_player {
                    return Some(true);
                }
            }
        }
    }

    Some(false)
}

/**
    Checks whether or not the current player can take the opponent's king.
    This function can be used to verify that a move/moveset is legal by passing it the newly generated `PartialGame`.
    It differs from `is_in_check`, as it looks at the *current player's* moves, instead of the *opponent's* moves.
**/
pub fn is_illegal<'a>(game: &'a Game, partial_game: &'a PartialGame<'a>) -> Option<bool> {
    for board in partial_game.own_boards(game) {
        for mv in board.generate_moves_flag(game, partial_game, GenMovesFlag::Check)? {
            if let Some(piece) = mv.to.0 {
                if piece.is_royal() && piece.white != partial_game.info.active_player {
                    return Some(true);
                }
            }
        }
    }

    Some(false)
}
