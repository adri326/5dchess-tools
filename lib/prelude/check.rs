use super::*;
use std::collections::HashMap;

/**
    Generates idle boards. Idle boards are defined as such:
    - take the present, active boards owned by the current player
    - copy them and add them to the end of their timeline, effectively passing them to the opponent
**/
pub fn generate_idle_boards<'a, B>(
    game: &'a Game,
    partial_game: &'a PartialGame<'a, B>
) -> Option<PartialGame<'a, B>>
where
    B: Clone + AsRef<Board> + AsMut<Board>,
    for<'b> B: From<(Board, &'b Game, &'b PartialGame<'b, B>)>,
{
    let mut new_partial_game = PartialGame::new(
        HashMap::new(),
        partial_game.info.clone(),
        None
    );

    for board in partial_game.own_boards(game) {
        if board.t() == partial_game.info.present {
            match board {
                BoardOr::Board(board) => {
                    let mut n_board = board.clone();
                    n_board.t += 1;
                    n_board.en_passant = None;
                    new_partial_game.insert(B::from((n_board, game, partial_game)));
                    new_partial_game.info.get_timeline_mut(board.l())?.last_board += 1;
                }
                BoardOr::B(board) => {
                    let mut n_board = board.clone();
                    n_board.as_mut().t += 1;
                    n_board.as_mut().en_passant = None;
                    new_partial_game.insert(n_board);
                    new_partial_game.info.get_timeline_mut(board.as_ref().l())?.last_board += 1;
                }
            }
        }
    }

    new_partial_game.parent = Some(partial_game);
    Some(new_partial_game)
}

/**
    Checks whether or not the opponent can currently take the current player's king.
    This function can be used to verify that a position is in check by passing it the IDLE boards, generated by `generate_idle_boards`.
    It differs from `is_illegal`, as it looks at the *opponent's* moves, instead of the *current player's* moves.

    This function would benefit from `B` quickly yielding the checking moves.
    The function `B::generate_moves_flag(GenMovesFlag::Check, ...)` will be called for this.
    If your function would benefit from knowing that it needs to first yield the checking moves, then you should implement your own version of `B::generate_moves_flag`.
**/
pub fn is_in_check<'a, B>(
    game: &'a Game,
    partial_game: &'a PartialGame<'a, B>
) -> Option<bool>
where
    B: Clone + AsRef<Board> + AsMut<Board>,
    for<'b> &'b B: GenMoves<'b, B>,
    for<'b> B: From<(Board, &'b Game, &'b PartialGame<'b, B>)>,
{
    for board in partial_game.opponent_boards(game) {
        for mv in board.generate_moves_flag(game, partial_game, GenMovesFlag::Check)? {
            if let Some(piece) = mv.to.0 {
                if piece.is_royal() && piece.white == partial_game.info.active_player {
                    return Some(true)
                }
            }
        }
    }

    Some(false)
}

/**
    Checks whether or not the current player can take the opponent's king.
    This function can be used to verify that a move/moveset is legal by passing it the newly generated `PartialGame`.
    It differs from `is_in_check`, as it looks at the *current player's* moves, instead of the *opponent's* moves.

    This function would benefit from `B` quickly yielding the checking moves.
    The function `B::generate_moves_flag(GenMovesFlag::Check, ...)` will be called for this.
    If your function would benefit from knowing that it needs to first yield the checking moves, then you should implement your own version of `B::generate_moves_flag`.
**/
pub fn is_illegal<'a, B>(
    game: &'a Game,
    partial_game: &'a PartialGame<'a, B>
) -> Option<bool>
where
    B: Clone + AsRef<Board> + AsMut<Board>,
    for<'b> &'b B: GenMoves<'b, B>,
    for<'b> B: From<(Board, &'b Game, &'b PartialGame<'b, B>)>,
{
    for board in partial_game.own_boards(game) {
        for mv in board.generate_moves_flag(game, partial_game, GenMovesFlag::Check)? {
            if let Some(piece) = mv.to.0 {
                if piece.is_royal() && piece.white != partial_game.info.active_player {
                    return Some(true)
                }
            }
        }
    }

    Some(false)
}
