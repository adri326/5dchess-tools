use super::*;

/**
    Generates idle boards. Idle boards are defined as such:
    - take the present, active, playable boards owned by the current player
    - copy them and add them to the end of their timeline, effectively passing them to the opponent
**/
pub fn generate_idle_boards<'a>(
    game: &'a Game,
    partial_game: &'a PartialGame<'a>,
) -> Option<PartialGame<'a>> {
    let mut new_partial_game = PartialGame::empty(partial_game.info.clone(), None);

    for board in partial_game.own_boards(game) {
        if board.t() == partial_game.info.present {
            let mut n_board = board.clone();
            n_board.t += 1;
            n_board.en_passant = None;
            new_partial_game.insert(n_board);
            new_partial_game
                .info
                .get_timeline_mut(board.l())?
                .last_board += 1;
        }
    }

    new_partial_game.parent = Some(partial_game);
    Some(new_partial_game)
}

/**
    Checks whether or not the opponent can currently take the current player's king.
    This function can be used to verify that a position is in check by passing it the IDLE boards, generated by `generate_idle_boards`; `is_in_check` does exactly that.
    It differs from `is_illegal`, as it looks at the *opponent's* moves, instead of the *current player's* moves.
**/
pub fn is_threatened<'a>(game: &'a Game, partial_game: &'a PartialGame<'a>) -> Option<(bool, Option<Move>)> {
    for board in partial_game.opponent_boards(game) {
        for mv in board.generate_moves_flag(game, partial_game, GenMovesFlag::Check)? {
            if let Some(piece) = mv.to.0 {
                if piece.is_royal() && piece.white == partial_game.info.active_player {
                    return Some((true, Some(mv)));
                }
            }
        }
    }

    Some((false, None))
}

/**
    Checks whether or not the current player can take the opponent's king.
    This function can be used to verify that a move/moveset is legal by passing it the newly generated `PartialGame`.
    It differs from `is_threatened`, as it looks at the *current player's* moves, instead of the *opponent's* moves.
**/
pub fn is_illegal<'a>(game: &'a Game, partial_game: &'a PartialGame<'a>) -> Option<(bool, Option<Move>)> {
    for board in partial_game.own_boards(game) {
        for mv in board.generate_moves_flag(game, partial_game, GenMovesFlag::Check)? {
            if let Some(piece) = mv.to.0 {
                if piece.is_royal() && piece.white != partial_game.info.active_player {
                    return Some((true, Some(mv)));
                }
            }
        }
    }

    Some((false, None))
}

/** Returns whether or not the current player is in check. Active, playable boards on the present are passed along and a threatening move by the opponent is searched.
    - Returns `Some((true, Some(move)))` if the opponent has a checking move.
    - Returns `Some((false, None))` if the opponent hasn't a checking move.
    - Returns `None` if there is an error while generating moves
    - While there is no code that will return `Some((true, None))`, you should cover that case as well for future-proofing.
**/
pub fn is_in_check<'a>(game: &'a Game, partial_game: &'a PartialGame<'a>) -> Option<(bool, Option<Move>)> {
    if let Some(new_partial_game) = generate_idle_boards(game, partial_game) {
        is_threatened(game, &new_partial_game)
    } else {
        None
    }
}
