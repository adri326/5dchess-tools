use super::*;

/**
    A goal - or objective - represents a condition that branches of the tree search must fulfill.
    The verification for the fulfillement of the condition is done using the `verify` function.
    It takes as argument:
    - a reference to a `Moveset`
    - a `&Game` reference
    - a `&PartialGame` reference, which corresponds to the new `PartialGame` generated by the `Moveset`
    - a depth value, representing the depth of the tree search

    If for instance, you wish to only keep the movesets where no new timeline gets created until depth>4, you'd do:

    ```
    pub struct MyGoal {
        pub min_timeline: Layer,
        pub max_timeline: Layer,
    }

    impl Goal for MyGoal {
        fn verify<'b>(
            &self,
            moveset: &'b Moveset,
            game: &'b Game,
            partial_game: &'b PartialGame<'b>,
            depth: usize
        ) -> Option<bool> {
            if depth > 4 {
                Some(true)
            } else {
                Some(
                    partial_game.info.min_timeline() == self.min_timeline
                    && partial_game.info.max_timeline() == self.max_timeline
                )
            }
        }
    }
    ```

    A similar goal can be found at `goals::misc::NoBranching`; it can achieve the same result by combining it with `UntilGoal`: `goals::misc::NoBranching::new(&game.info).until(4)`.

    You may use the included `or`, `and`, `not` and `until` functions to combine goals together.
**/
pub trait Goal {
    /**
        Required method. Return `Some(true)` if the given moveset is valid, `Some(false)` if it is invalid and `None` if an error occured.
    **/
    fn verify<'b>(
        &self,
        moveset: &'b Moveset,
        game: &'b Game,
        partial_game: &'b PartialGame<'b>,
        depth: usize,
    ) -> Option<bool>;

    fn or<G: Goal>(self, goal: G) -> OrGoal<Self, G>
    where
        Self: Sized,
    {
        OrGoal::new(self, goal)
    }

    fn and<G: Goal>(self, goal: G) -> AndGoal<Self, G>
    where
        Self: Sized,
    {
        AndGoal::new(self, goal)
    }

    fn not(self) -> NotGoal<Self>
    where
        Self: Sized,
    {
        NotGoal::new(self)
    }

    fn until(self, max_depth: usize) -> UntilGoal<Self>
    where
        Self: Sized,
    {
        UntilGoal::new(self, max_depth)
    }
}

/** A goal that will always return true. **/
pub struct TrueGoal;

impl Goal for TrueGoal {
    #[inline]
    fn verify<'b>(
        &self,
        _moveset: &'b Moveset,
        _game: &'b Game,
        _partial_game: &'b PartialGame<'b>,
        _depth: usize,
    ) -> Option<bool> {
        Some(true)
    }
}

/** A goal that will always return false. **/
pub struct FalseGoal;

impl Goal for FalseGoal {
    #[inline]
    fn verify<'b>(
        &self,
        _moveset: &'b Moveset,
        _game: &'b Game,
        _partial_game: &'b PartialGame<'b>,
        _depth: usize,
    ) -> Option<bool> {
        Some(false)
    }
}

/**
    A goal that will return true if its sub-goal returns false, representing the negation of its sub-goal.
    If the sub-goal fails (by returning `None`), it will also fail (by returning `None`).
**/
pub struct NotGoal<G>
where
    G: Goal,
{
    pub goal: G,
}

impl<G> NotGoal<G>
where
    G: Goal,
{
    pub fn new(goal: G) -> Self {
        Self { goal }
    }
}

impl<G> Goal for NotGoal<G>
where
    G: Goal,
{
    #[inline]
    fn verify<'b>(
        &self,
        moveset: &'b Moveset,
        game: &'b Game,
        partial_game: &'b PartialGame<'b>,
        depth: usize,
    ) -> Option<bool> {
        match self.goal.verify(moveset, game, partial_game, depth) {
            Some(x) => Some(!x),
            None => None,
        }
    }
}

/**
    A goal that will return true if either of its sub-goals returns true, representing the disjunction of both goals.
**/
pub struct OrGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    pub left: Left,
    pub right: Right,
}

impl<Left, Right> OrGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    pub fn new(left: Left, right: Right) -> Self {
        Self { left, right }
    }
}

impl<Left, Right> Goal for OrGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    #[inline]
    fn verify<'b>(
        &self,
        moveset: &'b Moveset,
        game: &'b Game,
        partial_game: &'b PartialGame<'b>,
        depth: usize,
    ) -> Option<bool> {
        match self.left.verify(moveset, game, partial_game, depth) {
            Some(false) => self.right.verify(moveset, game, partial_game, depth),
            x => x,
        }
    }
}

/**
    A goal that returns true if both sub-goals return true, representing the conjunction of both goals.
**/
pub struct AndGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    pub left: Left,
    pub right: Right,
}

impl<Left, Right> AndGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    pub fn new(left: Left, right: Right) -> Self {
        Self { left, right }
    }
}

impl<Left, Right> Goal for AndGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    #[inline]
    fn verify<'b>(
        &self,
        moveset: &'b Moveset,
        game: &'b Game,
        partial_game: &'b PartialGame<'b>,
        depth: usize,
    ) -> Option<bool> {
        match self.left.verify(moveset, game, partial_game, depth) {
            Some(true) => self.right.verify(moveset, game, partial_game, depth),
            x => x,
        }
    }
}

pub struct UntilGoal<G: Goal> {
    pub goal: G,
    pub max_depth: usize,
}

impl<G: Goal> UntilGoal<G> {
    pub fn new(goal: G, max_depth: usize) -> Self {
        Self { goal, max_depth }
    }
}

impl<G: Goal> Goal for UntilGoal<G> {
    #[inline]
    fn verify<'b>(
        &self,
        moveset: &'b Moveset,
        game: &'b Game,
        partial_game: &'b PartialGame<'b>,
        depth: usize,
    ) -> Option<bool> {
        if depth > self.max_depth {
            Some(false)
        } else {
            self.goal.verify(moveset, game, partial_game, depth)
        }
    }
}
