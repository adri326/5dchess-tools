use super::*;

/**
    A goal - or objective - represents a condition that branches of the tree search must fulfill.
    The verification for the fulfillement of the condition is done using the `verify` function.
    It takes as argument:
    - a reference to a `Moveset`
    - a `&Game` reference
    - a `&PartialGame` reference, which corresponds to the new `PartialGame` generated by the `Moveset`
    - a depth value, representing the depth of the tree search

    If for instance, you wish to only keep the movesets where no new timeline gets created until depth>4, you'd do:

    ```
    pub struct MyGoal {
        pub min_timeline: Layer,
        pub max_timeline: Layer,
    }

    impl Goal for MyGoal {
        fn verify<'b>(
            &self,
            moveset: &'b Moveset,
            game: &'b Game,
            partial_game: &'b PartialGame<'b>,
            depth: usize
        ) -> GoalResult {
            if depth > 4 {
                Some(true)
            } else {
                Some(
                    partial_game.info.min_timeline() == self.min_timeline
                    && partial_game.info.max_timeline() == self.max_timeline
                )
            }
        }
    }
    ```

    A similar goal can be found at `goals::misc::NoBranching`; it can achieve the same result by combining it with `UntilGoal`: `goals::misc::NoBranching::new(&game.info).until(4)`.

    You may use the included `or`, `and`, `not` and `until` functions to combine goals together.
**/
pub trait Goal: Copy + Send {
    /**
        Required method. Return `Some(true)` if the given moveset is valid, `Some(false)` if it is invalid and `None` if an error occured.
    **/
    fn verify<'b>(
        &self,
        path: &'b [Moveset], // TODO: &'b [Cow<Moveset>]?
        game: &'b Game,
        partial_game: &'b PartialGame<'b>,
        max_depth: Option<usize>,
    ) -> GoalResult;

    /**
        Combines two goals, stopping if either stops or claims a win/loss
    **/
    fn or<G: Goal>(self, goal: G) -> OrGoal<Self, G>
    where
        Self: Sized,
    {
        OrGoal::new(self, goal)
    }

    /**
        Combines two goals, stopping if both claim a win/loss or stop
    **/
    fn and<G: Goal>(self, goal: G) -> AndGoal<Self, G>
    where
        Self: Sized,
    {
        AndGoal::new(self, goal)
    }

    /**
        Inverts a goal, claiming a loss if a win is claimed, a win if a loss is claimed and negating the score of a GameResult::Score value.
    **/
    fn not(self) -> NotGoal<Self>
    where
        Self: Sized,
    {
        NotGoal::new(self)
    }

    /**
        Only applies a goal up to a given depth. Beyond that depth, GameResult::Continue is always returned.
    **/
    fn until(self, max_depth: usize) -> UntilGoal<Self>
    where
        Self: Sized,
    {
        UntilGoal::new(self, max_depth)
    }
}

/// Value returned by a Goal, represents what decision a tree search algorithm should make
pub enum GoalResult {
    /// If the last move in a goal's given path results in the **current player** (the one about to play) winning
    Win,
    /// If the last move in a goal's given path results in the **current player** (the one about to play) losing
    Loss,
    /// Continue the tree search as normal
    Continue,
    /// Do not continue searching down the given path; a score may be given to that node or it may be ignored
    Stop,
    /// Give the node a set score
    Score(crate::eval::Eval),
    /// Error out
    Error,
}

/** A goal that will always return GameResult::Continue. **/
#[derive(Clone, Copy)]
pub struct ContinueGoal;

impl Goal for ContinueGoal {
    #[inline]
    fn verify<'b>(
        &self,
        _path: &'b [Moveset],
        _game: &'b Game,
        _partial_game: &'b PartialGame<'b>,
        _max_depth: Option<usize>,
    ) -> GoalResult {
        GoalResult::Continue
    }
}

/** A goal that will always return GameResult::Stop. **/
#[derive(Clone, Copy)]
pub struct StopGoal;

impl Goal for StopGoal {
    #[inline]
    fn verify<'b>(
        &self,
        _path: &'b [Moveset],
        _game: &'b Game,
        _partial_game: &'b PartialGame<'b>,
        _max_depth: Option<usize>,
    ) -> GoalResult {
        GoalResult::Stop
    }
}

/**
    A goal that inverts a goal, claiming a loss if a win is claimed, a win if a loss is claimed and negating the score of a GameResult::Score value.
**/
#[derive(Clone, Copy)]
pub struct NotGoal<G>
where
    G: Goal,
{
    pub goal: G,
}

impl<G> NotGoal<G>
where
    G: Goal,
{
    pub fn new(goal: G) -> Self {
        Self { goal }
    }
}

impl<G> Goal for NotGoal<G>
where
    G: Goal,
{
    #[inline]
    fn verify<'b>(
        &self,
        path: &'b [Moveset],
        game: &'b Game,
        partial_game: &'b PartialGame<'b>,
        max_depth: Option<usize>,
    ) -> GoalResult {
        match self.goal.verify(path, game, partial_game, max_depth) {
            GoalResult::Win => GoalResult::Loss,
            GoalResult::Loss => GoalResult::Win,
            GoalResult::Score(x) => GoalResult::Score(-x),
            x => x,
        }
    }
}

/**
    A goal that combines two goals, stopping if either stops or claims a win/loss
**/
#[derive(Clone, Copy)]
pub struct OrGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    pub left: Left,
    pub right: Right,
}

impl<Left, Right> OrGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    pub fn new(left: Left, right: Right) -> Self {
        Self { left, right }
    }
}

impl<Left, Right> Goal for OrGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    #[inline]
    fn verify<'b>(
        &self,
        path: &'b [Moveset],
        game: &'b Game,
        partial_game: &'b PartialGame<'b>,
        max_depth: Option<usize>,
    ) -> GoalResult {
        match self.left.verify(path, game, partial_game, max_depth) {
            GoalResult::Continue => self.right.verify(path, game, partial_game, max_depth),
            x => x,
        }
    }
}

/**
    A goal that combines two goals, stopping if both claim a win/loss or stop or if either encounters an error
**/
#[derive(Clone, Copy)]
pub struct AndGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    pub left: Left,
    pub right: Right,
}

impl<Left, Right> AndGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    pub fn new(left: Left, right: Right) -> Self {
        Self { left, right }
    }
}

impl<Left, Right> Goal for AndGoal<Left, Right>
where
    Left: Goal,
    Right: Goal,
{
    #[inline]
    fn verify<'b>(
        &self,
        path: &'b [Moveset],
        game: &'b Game,
        partial_game: &'b PartialGame<'b>,
        max_depth: Option<usize>,
    ) -> GoalResult {
        match self.left.verify(path, game, partial_game, max_depth) {
            GoalResult::Win => {
                match self.right.verify(path, game, partial_game, max_depth) {
                    GoalResult::Win => GoalResult::Win,
                    GoalResult::Error => GoalResult::Error,
                    _ => GoalResult::Continue
                }
            },
            GoalResult::Loss => {
                match self.right.verify(path, game, partial_game, max_depth) {
                    GoalResult::Loss => GoalResult::Loss,
                    GoalResult::Error => GoalResult::Error,
                    _ => GoalResult::Continue
                }
            },
            GoalResult::Stop => {
                match self.right.verify(path, game, partial_game, max_depth) {
                    GoalResult::Stop => GoalResult::Stop,
                    GoalResult::Error => GoalResult::Error,
                    _ => GoalResult::Continue
                }
            },
            x => x,
        }
    }
}

/// A goal that only applies a goal up to a given depth. Beyond that depth, GameResult::Continue is always returned.
#[derive(Clone, Copy)]
pub struct UntilGoal<G: Goal> {
    pub goal: G,
    pub max_depth: usize,
}

impl<G: Goal> UntilGoal<G> {
    pub fn new(goal: G, max_depth: usize) -> Self {
        Self { goal, max_depth }
    }
}

impl<G: Goal> Goal for UntilGoal<G> {
    #[inline]
    fn verify<'b>(
        &self,
        path: &'b [Moveset],
        game: &'b Game,
        partial_game: &'b PartialGame<'b>,
        max_depth: Option<usize>,
    ) -> GoalResult {
        let depth = path.len();
        if depth > self.max_depth {
            GoalResult::Continue
        } else {
            self.goal.verify(path, game, partial_game, max_depth)
        }
    }
}
