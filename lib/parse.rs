use crate::game::{Board, Game, Layer, Physical, Piece, PieceKind, Time, TimelineInfo};
use serde::Deserialize;
use std::collections::HashMap;

/// Represents a game state
#[derive(Debug, Deserialize)]
struct GameRaw {
    timelines: Vec<TimelineRaw>,
    width: Physical,
    height: Physical,
    active_player: bool,
}

/// Represents an in-game timeline
#[derive(Debug, Deserialize)]
struct TimelineRaw {
    index: f32,
    states: Vec<Vec<usize>>,
    width: u8,
    height: u8,
    begins_at: isize,
    emerges_from: Option<f32>,
}

/** Parses a JSON-encoded game state into a Game instance.
    The JSON has to be generated by [5dchess-notation](https://github.com/adri326/5dchess-notation/).
**/

// TODO: fill in the has_moved field
pub fn parse(raw: &str) -> Option<Game> {
    let game_raw: GameRaw = serde_json::from_str(raw).ok()?;

    let even_timelines = game_raw
        .timelines
        .iter()
        .any(|tl| tl.index == -0.5 || tl.index == 0.5);
    let timelines_white: Vec<TimelineInfo> = game_raw
        .timelines
        .iter()
        .filter(|tl| tl.index >= 0.0)
        .map(|tl| {
            TimelineInfo::new(
                de_layer(tl.index, even_timelines),
                tl.emerges_from
                    .map(|l| (de_layer(l, even_timelines), tl.begins_at - 1)),
                tl.begins_at as Time + tl.states.len() as Time - 1,
            )
        })
        .collect();
    let timelines_black: Vec<TimelineInfo> = game_raw
        .timelines
        .iter()
        .filter(|tl| tl.index < 0.0)
        .map(|tl| {
            TimelineInfo::new(
                de_layer(tl.index, even_timelines),
                tl.emerges_from
                    .map(|l| (de_layer(l, even_timelines), tl.begins_at as Time - 1)),
                tl.begins_at as Time + tl.states.len() as Time - 1,
            )
        })
        .collect();

    let mut boards: HashMap<(Layer, Time), Board> = HashMap::new();

    for timeline in game_raw.timelines.iter() {
        let layer: Layer = de_layer(timeline.index, even_timelines);
        for (dt, board_raw) in timeline.states.iter().enumerate() {
            let time: Time = timeline.begins_at as Time + dt as Time;

            // Note that any unknown piece will be interpreted as a blank square
            let pieces: Vec<Option<Piece>> = board_raw
                .iter()
                .map(|piece_raw| de_piece(*piece_raw))
                .collect();

            let board: Board = Board::new(game_raw.width, game_raw.height, layer, time, pieces);
            boards.insert((layer, time), board);
        }
    }

    let mut res = Game::new(
        game_raw.width as Physical,
        game_raw.height as Physical,
        even_timelines,
        timelines_white,
        timelines_black,
    );
    res.boards = boards;
    return Some(res);
}


/** Deserializes a layer coordinate serialized as an `f32`-encoded number. **/
pub fn de_layer(raw: f32, even_timelines: bool) -> Layer {
    if even_timelines && raw < 0.0 {
        (raw.ceil() - 1.0) as Layer
    } else {
        raw.floor() as Layer
    }
}

/** Deserializes a piece serialized as a `usize`-encoded number.
    This list is based on `5dchess-notation`: https://github.com/adri326/5dchess-notation/blob/master/parsers/game.js#L12
**/
pub fn de_piece(raw: usize) -> Option<Piece> {
    Some(match raw {
        1 => Piece::new(PieceKind::Pawn, true, false),
        2 => Piece::new(PieceKind::Knight, true, false),
        3 => Piece::new(PieceKind::Bishop, true, false),
        4 => Piece::new(PieceKind::Rook, true, false),
        5 => Piece::new(PieceKind::Queen, true, false),
        6 => Piece::new(PieceKind::King, true, false),
        7 => Piece::new(PieceKind::Unicorn, true, false),
        8 => Piece::new(PieceKind::Dragon, true, false),
        9 => Piece::new(PieceKind::Princess, true, false),
        10 => Piece::new(PieceKind::Brawn, true, false),
        11 => Piece::new(PieceKind::CommonKing, true, false),
        12 => Piece::new(PieceKind::RoyalQueen, true, false),

        33 => Piece::new(PieceKind::Pawn, false, false),
        34 => Piece::new(PieceKind::Knight, false, false),
        35 => Piece::new(PieceKind::Bishop, false, false),
        36 => Piece::new(PieceKind::Rook, false, false),
        37 => Piece::new(PieceKind::Queen, false, false),
        38 => Piece::new(PieceKind::King, false, false),
        39 => Piece::new(PieceKind::Unicorn, false, false),
        40 => Piece::new(PieceKind::Dragon, false, false),
        41 => Piece::new(PieceKind::Princess, false, false),
        42 => Piece::new(PieceKind::Brawn, false, false),
        43 => Piece::new(PieceKind::CommonKing, false, false),
        44 => Piece::new(PieceKind::RoyalQueen, false, false),

        _ => return None,
    })
}
