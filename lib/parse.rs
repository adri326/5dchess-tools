use crate::prelude::{Board, Game, Layer, Physical, Piece, PieceKind, Time, TimelineInfo};
use crate::traversal::bubble_down_mut;
use serde::Deserialize;
use std::collections::HashMap;

/// Represents a game state
#[derive(Debug, Deserialize)]
struct GameRaw {
    timelines: Vec<TimelineRaw>,
    width: Physical,
    height: Physical,
    active_player: bool,
    initial_board_indices: Vec<f32>,
}

/// Represents an in-game timeline
#[derive(Debug, Deserialize)]
struct TimelineRaw {
    index: f32,
    states: Vec<Vec<usize>>,
    width: u8,
    height: u8,
    begins_at: isize,
    emerges_from: Option<f32>,
}

/** Parses a JSON-encoded game state into a Game instance.
    The JSON has to be generated by [5dchess-notation](https://github.com/adri326/5dchess-notation/).
**/
pub fn parse(raw: &str) -> Option<Game> {
    let game_raw: GameRaw = serde_json::from_str(raw).ok()?;

    let even_timelines = game_raw
        .timelines
        .iter()
        .any(|tl| tl.index == -0.5 || tl.index == 0.5);
    let timelines_white: Vec<TimelineInfo> = game_raw
        .timelines
        .iter()
        .filter(|tl| tl.index >= 0.0)
        .map(|tl| {
            TimelineInfo::new(
                de_layer(tl.index, even_timelines),
                tl.emerges_from
                    .map(|l| (de_layer(l, even_timelines), tl.begins_at - 1)),
                tl.begins_at as Time + tl.states.len() as Time - 1,
                tl.begins_at as Time,
            )
        })
        .collect();
    let timelines_black: Vec<TimelineInfo> = game_raw
        .timelines
        .iter()
        .filter(|tl| tl.index < 0.0)
        .map(|tl| {
            TimelineInfo::new(
                de_layer(tl.index, even_timelines),
                tl.emerges_from
                    .map(|l| (de_layer(l, even_timelines), tl.begins_at as Time - 1)),
                tl.begins_at as Time + tl.states.len() as Time - 1,
                tl.begins_at as Time,
            )
        })
        .collect();

    let mut boards: HashMap<(Layer, Time), Board> = HashMap::new();

    for timeline in game_raw.timelines.iter() {
        let layer: Layer = de_layer(timeline.index, even_timelines);
        for (dt, board_raw) in timeline.states.iter().enumerate() {
            let time: Time = timeline.begins_at as Time + dt as Time;

            // Note that any unknown piece will be interpreted as a blank square
            let pieces: Vec<Option<Piece>> = board_raw
                .iter()
                .map(|piece_raw| de_piece(*piece_raw))
                .collect();

            let board: Board = Board::new(game_raw.width, game_raw.height, layer, time, pieces);
            boards.insert((layer, time), board);
        }
    }

    let mut res = Game::new(
        game_raw.width as Physical,
        game_raw.height as Physical,
        even_timelines,
        timelines_white,
        timelines_black,
    );
    res.boards = boards;

    // Fill in the "moved" field of the pieces
    for layer in game_raw
        .initial_board_indices
        .iter()
        .map(|l| de_layer(*l, even_timelines))
    {
        let first_board = res.info.get_timeline(layer)?.first_board;
        let coords = (layer, first_board);
        let board_size = game_raw.width as usize * game_raw.height as usize;

        let mut initial_state: Vec<Option<Piece>> = Vec::new();

        for index in 0..board_size {
            initial_state.push(res.get(
                coords.0,
                coords.1,
                (index % game_raw.width as usize) as Physical,
                (index / game_raw.width as usize) as Physical,
            ));
        }

        bubble_down_mut(
            &mut res,
            coords,
            |board, _coords, mut state| {
                // For each piece...
                for index in 0..board_size {
                    if board.pieces[index] == state[index] {
                        // If the piece didn't move...
                        board.pieces[index] = match board.pieces[index] {
                            Some(mut piece) => {
                                piece.moved = false; // Set its flag to false
                                Some(piece)
                            }
                            x => x,
                        };
                    } else {
                        // If the piece moved...
                        match board.pieces[index] {
                            Some(mut piece) => piece.moved = true, // Set its flag to true
                            _ => (),
                        }
                        state[index] = None;
                    }
                }

                state
            },
            initial_state,
        );
    }

    return Some(res);
}

/** Deserializes a layer coordinate serialized as an `f32`-encoded number. **/
pub fn de_layer(raw: f32, even_timelines: bool) -> Layer {
    if even_timelines && raw < 0.0 {
        (raw.ceil() - 1.0) as Layer
    } else {
        raw.floor() as Layer
    }
}

/** Deserializes a piece serialized as a `usize`-encoded number.
    This list is based on `5dchess-notation`: https://github.com/adri326/5dchess-notation/blob/master/parsers/game.js#L12
**/
pub fn de_piece(raw: usize) -> Option<Piece> {
    Some(match raw {
        1 => Piece::new(PieceKind::Pawn, true, true),
        2 => Piece::new(PieceKind::Knight, true, true),
        3 => Piece::new(PieceKind::Bishop, true, true),
        4 => Piece::new(PieceKind::Rook, true, true),
        5 => Piece::new(PieceKind::Queen, true, true),
        6 => Piece::new(PieceKind::King, true, true),
        7 => Piece::new(PieceKind::Unicorn, true, true),
        8 => Piece::new(PieceKind::Dragon, true, true),
        9 => Piece::new(PieceKind::Princess, true, true),
        10 => Piece::new(PieceKind::Brawn, true, true),
        11 => Piece::new(PieceKind::CommonKing, true, true),
        12 => Piece::new(PieceKind::RoyalQueen, true, true),

        33 => Piece::new(PieceKind::Pawn, false, true),
        34 => Piece::new(PieceKind::Knight, false, true),
        35 => Piece::new(PieceKind::Bishop, false, true),
        36 => Piece::new(PieceKind::Rook, false, true),
        37 => Piece::new(PieceKind::Queen, false, true),
        38 => Piece::new(PieceKind::King, false, true),
        39 => Piece::new(PieceKind::Unicorn, false, true),
        40 => Piece::new(PieceKind::Dragon, false, true),
        41 => Piece::new(PieceKind::Princess, false, true),
        42 => Piece::new(PieceKind::Brawn, false, true),
        43 => Piece::new(PieceKind::CommonKing, false, true),
        44 => Piece::new(PieceKind::RoyalQueen, false, true),

        _ => return None,
    })
}
