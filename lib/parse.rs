use crate::prelude::{
    Board, Coords, Game, Layer, Physical, Piece, PieceKind, Tile, Time, TimelineInfo,
};
use crate::traversal::bubble_down_mut;
use regex::Regex;
use serde::Deserialize;
use std::collections::HashMap;
use std::fmt;
use std::str::FromStr;
use std::path::Path;
use std::fs;

/// Represents a game state
#[derive(Debug, Deserialize)]
struct GameRaw {
    timelines: Vec<TimelineRaw>,
    width: Physical,
    height: Physical,
    active_player: bool,
    initial_board_indices: Vec<f32>,
}

/// Represents an in-game timeline
#[derive(Debug, Deserialize)]
struct TimelineRaw {
    index: f32,
    states: Vec<Vec<usize>>,
    width: u8,
    height: u8,
    begins_at: isize,
    emerges_from: Option<f32>,
}

/** Parses a JSON-encoded game state into a Game instance.
    The JSON has to be generated by [5dchess-notation](https://github.com/adri326/5dchess-notation/).
**/
pub fn parse(raw: &str) -> Option<Game> {
    let game_raw: GameRaw = serde_json::from_str(raw).ok()?;

    let even_timelines = game_raw
        .timelines
        .iter()
        .any(|tl| tl.index == -0.5 || tl.index == 0.5);
    let timelines_white: Vec<TimelineInfo> = game_raw
        .timelines
        .iter()
        .filter(|tl| tl.index >= 0.0)
        .map(|tl| {
            TimelineInfo::new(
                de_layer(tl.index, even_timelines),
                tl.emerges_from
                    .map(|l| (de_layer(l, even_timelines), tl.begins_at - 1)),
                tl.begins_at as Time + tl.states.len() as Time - 1,
                tl.begins_at as Time,
            )
        })
        .collect();
    let timelines_black: Vec<TimelineInfo> = game_raw
        .timelines
        .iter()
        .filter(|tl| tl.index < 0.0)
        .map(|tl| {
            TimelineInfo::new(
                de_layer(tl.index, even_timelines),
                tl.emerges_from
                    .map(|l| (de_layer(l, even_timelines), tl.begins_at as Time - 1)),
                tl.begins_at as Time + tl.states.len() as Time - 1,
                tl.begins_at as Time,
            )
        })
        .collect();

    let mut res = Game::new(
        game_raw.width as Physical,
        game_raw.height as Physical,
        even_timelines,
        timelines_white,
        timelines_black,
    );

    for timeline in game_raw.timelines.iter() {
        let layer: Layer = de_layer(timeline.index, even_timelines);
        for (dt, board_raw) in timeline.states.iter().enumerate() {
            let time: Time = timeline.begins_at as Time + dt as Time;

            // Note that any unknown piece will be interpreted as a blank square
            let pieces: Vec<Tile> = board_raw
                .iter()
                .map(|piece_raw| de_piece(*piece_raw))
                .collect();

            let board: Board = Board::new(
                game_raw.width,
                game_raw.height,
                layer,
                time,
                pieces,
                None,
                None,
            );
            res.insert_board(board);
        }
    }

    // Fill in the "moved" field of the pieces
    for layer in game_raw
        .initial_board_indices
        .iter()
        .map(|l| de_layer(*l, even_timelines))
    {
        let first_board = res.info.get_timeline(layer)?.first_board;
        let coords = (layer, first_board);
        let board_size = game_raw.width as usize * game_raw.height as usize;

        let mut initial_state: Vec<Tile> = Vec::new();

        for index in 0..board_size {
            let piece = res.get(Coords(
                coords.0,
                coords.1,
                (index % game_raw.width as usize) as Physical,
                (index / game_raw.width as usize) as Physical,
            ));
            let piece = match piece {
                Tile::Piece(mut p) => {
                    p.moved = false;
                    Tile::Piece(p)
                }
                Tile::Blank => Tile::Blank,
                Tile::Void => panic!("Void in board!"),
            };
            initial_state.push(piece);
        }

        let initial_board = res.get_board((layer, first_board))?.clone();

        bubble_down_mut(
            &mut res,
            coords,
            |board, _coords, (mut state, previous_board)| {
                // For each piece...
                for index in 0..board_size {
                    let x = (index % game_raw.width as usize) as Physical;
                    let y = (index / game_raw.width as usize) as Physical;

                    if cmp_pieces(board.pieces[index], state[index]) {
                        // If the piece didn't move...
                        board.pieces[index] = match board.pieces[index] {
                            Tile::Piece(mut piece) => {
                                piece.moved = state[index].piece().unwrap().moved; // Set its flag to false
                                Tile::Piece(piece)
                            }
                            x => x,
                        };
                    } else {
                        // If the piece moved...
                        board.pieces[index] = match board.pieces[index] {
                            Tile::Piece(mut piece) => {
                                piece.moved = true; // Set its flag to true

                                // If it is a pawn-like piece, fill in the en_passant field
                                if piece.can_kickstart() {
                                    if piece.white {
                                        if previous_board.get((x, y - 1)).is_empty() {
                                            board.set_en_passant(Some((x, y - 1)))
                                        }
                                    } else {
                                        if previous_board.get((x, y + 1)).is_empty() {
                                            board.set_en_passant(Some((x, y + 1)))
                                        }
                                    }
                                }

                                // If it is a king-like piece, fill in the castle field
                                if piece.can_castle() {
                                    // Left
                                    if x > 1
                                        && !cmp_pieces(
                                            previous_board.get((x - 1, y)),
                                            board.get((x - 1, y)),
                                        )
                                        && !cmp_pieces(
                                            previous_board.get((x - 2, y)),
                                            board.get((x - 2, y)),
                                        )
                                    {
                                        board.set_castle(Some((x - 1, y, x - 2, y)));
                                    } else if x < game_raw.width - 2
                                        && !cmp_pieces(
                                            previous_board.get((x + 1, y)),
                                            board.get((x + 1, y)),
                                        )
                                        && !cmp_pieces(
                                            previous_board.get((x + 2, y)),
                                            board.get((x + 2, y)),
                                        )
                                    {
                                        board.set_castle(Some((x + 1, y, x + 2, y)));
                                    }
                                }

                                Tile::Piece(piece)
                            }
                            x => x,
                        };
                        state[index] = board.pieces[index];
                    }
                }

                (state, board.clone())
            },
            (initial_state, initial_board),
        );
    }

    return Some(res);
}

/** Deserializes a layer coordinate serialized as an `f32`-encoded number. **/
pub fn de_layer(raw: f32, even_timelines: bool) -> Layer {
    if even_timelines && raw < 0.0 {
        (raw.ceil() - 1.0) as Layer
    } else {
        raw.floor() as Layer
    }
}

pub fn de_str_layer(raw: &str, even_timelines: bool) -> Layer {
    if raw == "-0" {
        -1
    } else if raw == "+0" {
        0
    } else {
        let parsed = Layer::from_str(raw).unwrap();
        if parsed < 0 && even_timelines {
            parsed - 1
        } else {
            parsed
        }
    }
}

/** Deserializes a piece serialized as a `usize`-encoded number.
    This list is based on `5dchess-notation`: https://github.com/adri326/5dchess-notation/blob/master/parsers/game.js#L12
**/
pub fn de_piece(raw: usize) -> Tile {
    Tile::Piece(match raw {
        1 => Piece::new(PieceKind::Pawn, true, true),
        2 => Piece::new(PieceKind::Knight, true, true),
        3 => Piece::new(PieceKind::Bishop, true, true),
        4 => Piece::new(PieceKind::Rook, true, true),
        5 => Piece::new(PieceKind::Queen, true, true),
        6 => Piece::new(PieceKind::King, true, true),
        7 => Piece::new(PieceKind::Unicorn, true, true),
        8 => Piece::new(PieceKind::Dragon, true, true),
        9 => Piece::new(PieceKind::Princess, true, true),
        10 => Piece::new(PieceKind::Brawn, true, true),
        11 => Piece::new(PieceKind::CommonKing, true, true),
        12 => Piece::new(PieceKind::RoyalQueen, true, true),

        33 => Piece::new(PieceKind::Pawn, false, true),
        34 => Piece::new(PieceKind::Knight, false, true),
        35 => Piece::new(PieceKind::Bishop, false, true),
        36 => Piece::new(PieceKind::Rook, false, true),
        37 => Piece::new(PieceKind::Queen, false, true),
        38 => Piece::new(PieceKind::King, false, true),
        39 => Piece::new(PieceKind::Unicorn, false, true),
        40 => Piece::new(PieceKind::Dragon, false, true),
        41 => Piece::new(PieceKind::Princess, false, true),
        42 => Piece::new(PieceKind::Brawn, false, true),
        43 => Piece::new(PieceKind::CommonKing, false, true),
        44 => Piece::new(PieceKind::RoyalQueen, false, true),

        _ => return Tile::Blank,
    })
}

// Returns whether or not left.kind == right.kind and left.white == right.white
pub fn cmp_pieces(left: Tile, right: Tile) -> bool {
    match (left, right) {
        (Tile::Piece(l), Tile::Piece(r)) => l.kind == r.kind && l.white == r.white,
        (Tile::Blank, Tile::Blank) => true,
        (Tile::Void, _) | (_, Tile::Void) => panic!("Void in board!"),
        _ => false,
    }
}

/// This module should only be used for testing!
#[allow(dead_code)]
pub mod test {
    use super::*;
    use std::fs::File;
    use std::io::Read;

    pub fn read_and_parse(path: &str) -> Game {
        let file = File::open(path).ok();
        assert!(file.is_some(), "Couldn't open `{}`!", path);
        let mut contents = String::new();

        assert!(
            file.unwrap().read_to_string(&mut contents).is_ok(),
            "Couldn't read `{}`!",
            path
        );

        let res = parse(&contents);
        assert!(res.is_some(), "Couldn't parse `{}`!", path);
        res.unwrap()
    }

    pub fn read_and_parse_opt(path: &str) -> Option<Game> {
        let mut file = File::open(path).ok()?;
        let mut contents = String::new();

        file.read_to_string(&mut contents).ok()?;

        parse(&contents)
    }
}

/// Represents an error encountered while parsing a PGN string
pub enum PGNParseError {
    InvalidHeader(String),
    FENDimensionX(String, Physical, usize),
    FENDimensionY(String, Physical, usize),
    FENUnexpected(String, String),
    InvalidVariant(String),
}

/// Parses a PGN string, returning the corresponding `Game` instance if possible
pub fn parse_pgn(raw: &str, variants: Option<&Path>) -> Result<Game, PGNParseError> {
    let variant_regexp = Regex::new("^[a-zA-Z \\-]+$").unwrap();
    let mut headers: HashMap<String, String> = HashMap::new();
    let mut fens = Vec::new();

    parse_headers(raw, &mut headers, &mut fens)?;

    let (mut width, mut height) = get_dimensions(&headers);

    let mut game = Game::new(
        width,
        height,
        false,
        vec![TimelineInfo::new(0, None, 0, 0)],
        vec![],
    );

    // Custom board: parse fen
    if headers
        .get(&String::from("board"))
        .map(|x| x.to_lowercase())
        == Some("custom".to_string())
    {
        for fen in &fens {
            if fen[1] == "+0" || fen[1] == "-0" {
                game.info.even_timelines = true;
            }
        }

        for fen in fens {
            parse_and_insert_fen(fen, &mut game)?;
        }
    } else if variants.is_some() && headers.get(&String::from("board")).map(|b| variant_regexp.is_match(b)) == Some(true) {
        // Attempt to read the variant from the variants directory

        let variant = headers.get(&String::from("board")).unwrap();
        // Read the directory
        if let Ok(mut files) = fs::read_dir(variants.unwrap()) {
            // Find the directory of the variant
            if files.find(|d| {
                if let Ok(s) = d.as_ref().map(|d| d.path()) {
                    s.file_name().map(|s| s.to_str()).flatten().map(|s| s == variant).unwrap_or(false)
                } else {
                    false
                }
            }).is_some() {
                let mut path = variants.unwrap().join(variant);
                path.push("variant.5dpgn");
                let contents = std::fs::read_to_string(path).unwrap();
                fens = Vec::new();

                parse_headers(&contents, &mut headers, &mut fens)?;

                let (n_width, n_height) = get_dimensions(&headers);
                width = n_width;
                height = n_height;
                game = Game::new(
                    width,
                    height,
                    false,
                    vec![TimelineInfo::new(0, None, 0, 0)],
                    vec![],
                );

                for fen in &fens {
                    if fen[1] == "+0" || fen[1] == "-0" {
                        game.info.even_timelines = true;
                    }
                }

                for fen in fens {
                    parse_and_insert_fen(fen, &mut game)?;
                }
            } else {
                return Err(PGNParseError::InvalidVariant(variant.clone()));
            }
        } else {
            return Err(PGNParseError::InvalidVariant(variant.clone()));
        }
    } else {
        unimplemented!();
    }

    println!("{:#?}", headers);

    game.info.recalculate_present();

    Ok(game)
}

/// Parses a single FEN string (already split by the `:` character) and returns its corresponding `Board` if the FEN is valid
pub fn parse_fen(fen: Vec<&str>, game: &Game) -> Result<Board, PGNParseError> {
    let mut board = Board::new(
        game.width,
        game.height,
        de_str_layer(fen[1], game.info.even_timelines),
        (Time::from_str(fen[2]).unwrap() - 1) * 2 + (fen[3] != "w") as Time,
        vec![Tile::Blank; game.width as usize * game.height as usize],
        None,
        None,
    );
    let rows = fen[0].split("/").collect::<Vec<_>>();

    if rows.len() != game.height as usize {
        return Err(PGNParseError::FENDimensionY(
            fen[0].to_string(),
            game.height,
            rows.len(),
        ));
    }

    // for each row...
    for (y, row) in rows.into_iter().enumerate() {
        let y = board.height() as usize - y - 1;
        let mut x = 0;
        let mut skip = String::new();
        // for each char...
        for c in row.chars() {
            if c >= '0' && c <= '9' {
                skip.push(c);
            } else {
                if skip.len() > 0 {
                    x += usize::from_str(&skip).unwrap();
                    skip = String::new();
                }
                let kind = match c {
                    'p' | 'P' => PieceKind::Pawn,
                    'r' | 'R' => PieceKind::Rook,
                    'b' | 'B' => PieceKind::Bishop,
                    'u' | 'U' => PieceKind::Unicorn,
                    'd' | 'D' => PieceKind::Dragon,
                    'q' | 'Q' => PieceKind::Queen,
                    's' | 'S' => PieceKind::Princess,
                    'k' | 'K' => PieceKind::King,
                    'c' | 'C' => PieceKind::CommonKing,
                    'n' | 'N' => PieceKind::Knight,
                    'w' | 'W' => PieceKind::Brawn,
                    'y' | 'Y' => PieceKind::RoyalQueen,
                    '*' => {
                        if let Tile::Piece(ref mut p) =
                            &mut board.pieces[y * game.width as usize + x - 1]
                        {
                            p.moved = false;
                        } else {
                            return Err(PGNParseError::FENUnexpected(
                                String::from("*"),
                                row.to_string(),
                            ));
                        }
                        continue;
                    }
                    x => {
                        return Err(PGNParseError::FENUnexpected(
                            String::from(x),
                            row.to_string(),
                        ))
                    }
                };
                let white = c.is_ascii_uppercase();
                if x >= game.width as usize {
                    return Err(PGNParseError::FENDimensionX(
                        row.to_string(),
                        game.width,
                        x + 1,
                    ));
                }
                let tile = Tile::Piece(Piece::new(kind, white, false));
                board.set((x as Physical, y as Physical), tile);
                x += 1;
            }
        }
        if skip.len() > 0 {
            x += usize::from_str(&skip).unwrap();
        }
        if x != game.width as usize {
            return Err(PGNParseError::FENDimensionX(row.to_string(), game.width, x));
        }
    }

    Ok(board)
}

/// Parses a FEN string using `parse_fen` and appends it to the Game.
/// As there can be no gap in the timelines, empty timelines will be created.
/// Most functions will expect timelines to be non-empty, so you should make sure that these eventually get filled in.
pub fn parse_and_insert_fen(fen: Vec<&str>, game: &mut Game) -> Result<(), PGNParseError> {
    let board = parse_fen(fen, game)?;

    if let Some(ref mut tl) = game.info.get_timeline_mut(board.l) {
        tl.last_board = tl.last_board.max(board.t);
        tl.first_board = tl.first_board.min(board.t);
    } else {
        // create the timeline
        if board.l >= 0 {
            while game.info.timelines_white.len() + 1 < board.l as usize {
                game.info.timelines_white.push(TimelineInfo::new(
                    game.info.timelines_white.len() as Layer,
                    None,
                    0,
                    0,
                ));
            }
            game.info
                .timelines_white
                .push(TimelineInfo::new(board.l, None, board.t, board.t));
        } else {
            while game.info.timelines_black.len() + 2 < (-board.l) as usize {
                game.info.timelines_black.push(TimelineInfo::new(
                    -(game.info.timelines_black.len() as Layer) - 1,
                    None,
                    0,
                    0,
                ));
            }
            game.info
                .timelines_black
                .push(TimelineInfo::new(board.l, None, board.t, board.t));
        }
    }

    // for (i, bb) in board.bitboards.white.iter().enumerate() {
    //     println!("w{:2}: {:#066b}", i, bb);
    // }
    // println!("wr:  {:#066b}", board.bitboards.white_royal);
    // println!("wm:  {:#066b}", board.bitboards.white_movable);
    // for (i, bb) in board.bitboards.black.iter().enumerate() {
    //     println!("b{:2}: {:#066b}", i, bb);
    // }
    // println!("br:  {:#066b}", board.bitboards.black_royal);
    // println!("bm:  {:#066b}", board.bitboards.black_movable);

    println!("{:?}", board);
    game.insert_board(board);
    // println!("{:#?}", game);

    Ok(())
}

pub fn parse_headers<'a>(raw: &'a str, headers: &mut HashMap<String, String>, fens: &mut Vec<Vec<&'a str>>) -> Result<(), PGNParseError> {
    let header_regexp = Regex::new("^(\\w+)\\s+\"([^\"]+)\"$").unwrap();
    for line in raw.split("\n") {
        let line = line.trim();
        if line.chars().next() == Some('[') && line.chars().last() == Some(']') {
            if let Some(cap) = header_regexp.captures(&line[1..(line.len() - 1)]) {
                let name = cap.get(1).unwrap().as_str().to_lowercase();
                let value = cap.get(2).unwrap().as_str().to_string();
                headers.insert(name, value);
            } else {
                let fen_parts = line[1..(line.len() - 1)].split(":").collect::<Vec<_>>();
                if fen_parts.len() == 4 {
                    fens.push(fen_parts);
                } else {
                    return Err(PGNParseError::InvalidHeader(line.to_string()));
                }
            }
        }
    }
    Ok(())
}

fn get_dimensions(headers: &HashMap<String, String>) -> (Physical, Physical) {
    if let Some(raw_size) = headers.get(&String::from("size")) {
        let v = raw_size.split("x").collect::<Vec<_>>();
        if v.len() == 2 {
            v[0].parse::<Physical>()
                .ok()
                .map(|x| v[1].parse::<Physical>().ok().map(|y| (x, y)))
                .flatten()
                .unwrap_or((8, 8))
        } else {
            (8, 8)
        }
    } else {
        (8, 8)
    }
}

impl fmt::Debug for PGNParseError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PGNParseError::InvalidHeader(s) => write!(f, "Invalid header: `{}`", s),
            PGNParseError::FENDimensionX(s, expected, got) => write!(
                f,
                "Invalid FEN width dimension in `{}`: expected {}, got {}",
                s, expected, got
            ),
            PGNParseError::FENDimensionY(s, expected, got) => write!(
                f,
                "Invalid FEN height dimension in `{}`: expected {}, got {}",
                s, expected, got
            ),
            PGNParseError::FENUnexpected(s, t) => {
                write!(f, "Invalid token in FEN: '{}' in `{}`", t, s)
            },
            PGNParseError::InvalidVariant(v) => {
                write!(f, "Invalid variant: `{}`", v)
            }
        }
    }
}
