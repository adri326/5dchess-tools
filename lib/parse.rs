use crate::prelude::{
    Board, Coords, Game, Layer, Physical, Piece, PieceKind, Tile, Time, TimelineInfo,
};
use crate::traversal::bubble_down_mut;
use serde::Deserialize;
use std::collections::HashMap;

/// Represents a game state
#[derive(Debug, Deserialize)]
struct GameRaw {
    timelines: Vec<TimelineRaw>,
    width: Physical,
    height: Physical,
    active_player: bool,
    initial_board_indices: Vec<f32>,
}

/// Represents an in-game timeline
#[derive(Debug, Deserialize)]
struct TimelineRaw {
    index: f32,
    states: Vec<Vec<usize>>,
    width: u8,
    height: u8,
    begins_at: isize,
    emerges_from: Option<f32>,
}

/** Parses a JSON-encoded game state into a Game instance.
    The JSON has to be generated by [5dchess-notation](https://github.com/adri326/5dchess-notation/).
**/
pub fn parse(raw: &str) -> Option<Game> {
    let game_raw: GameRaw = serde_json::from_str(raw).ok()?;

    let even_timelines = game_raw
        .timelines
        .iter()
        .any(|tl| tl.index == -0.5 || tl.index == 0.5);
    let timelines_white: Vec<TimelineInfo> = game_raw
        .timelines
        .iter()
        .filter(|tl| tl.index >= 0.0)
        .map(|tl| {
            TimelineInfo::new(
                de_layer(tl.index, even_timelines),
                tl.emerges_from
                    .map(|l| (de_layer(l, even_timelines), tl.begins_at - 1)),
                tl.begins_at as Time + tl.states.len() as Time - 1,
                tl.begins_at as Time,
            )
        })
        .collect();
    let timelines_black: Vec<TimelineInfo> = game_raw
        .timelines
        .iter()
        .filter(|tl| tl.index < 0.0)
        .map(|tl| {
            TimelineInfo::new(
                de_layer(tl.index, even_timelines),
                tl.emerges_from
                    .map(|l| (de_layer(l, even_timelines), tl.begins_at as Time - 1)),
                tl.begins_at as Time + tl.states.len() as Time - 1,
                tl.begins_at as Time,
            )
        })
        .collect();

    let mut boards: HashMap<(Layer, Time), Board> = HashMap::new();

    for timeline in game_raw.timelines.iter() {
        let layer: Layer = de_layer(timeline.index, even_timelines);
        for (dt, board_raw) in timeline.states.iter().enumerate() {
            let time: Time = timeline.begins_at as Time + dt as Time;

            // Note that any unknown piece will be interpreted as a blank square
            let pieces: Vec<Tile> = board_raw
                .iter()
                .map(|piece_raw| de_piece(*piece_raw))
                .collect();

            let board: Board =
                Board::new(game_raw.width, game_raw.height, layer, time, pieces, None);
            boards.insert((layer, time), board);
        }
    }

    let mut res = Game::new(
        game_raw.width as Physical,
        game_raw.height as Physical,
        even_timelines,
        timelines_white,
        timelines_black,
    );
    res.boards = boards;

    // Fill in the "moved" field of the pieces
    for layer in game_raw
        .initial_board_indices
        .iter()
        .map(|l| de_layer(*l, even_timelines))
    {
        let first_board = res.info.get_timeline(layer)?.first_board;
        let coords = (layer, first_board);
        let board_size = game_raw.width as usize * game_raw.height as usize;

        let mut initial_state: Vec<Tile> = Vec::new();

        for index in 0..board_size {
            initial_state.push(res.get(Coords(
                coords.0,
                coords.1,
                (index % game_raw.width as usize) as Physical,
                (index / game_raw.width as usize) as Physical,
            )));
        }

        let initial_board = res.get_board((layer, first_board))?.clone();

        bubble_down_mut(
            &mut res,
            coords,
            |board, _coords, (mut state, previous_board)| {
                // For each piece...
                for index in 0..board_size {
                    let x = (index % game_raw.width as usize) as Physical;
                    let y = (index / game_raw.width as usize) as Physical;

                    if board.pieces[index] == state[index] {
                        // If the piece didn't move...
                        board.pieces[index] = match board.pieces[index] {
                            Tile::Piece(mut piece) => {
                                piece.moved = false; // Set its flag to false
                                Tile::Piece(piece)
                            }
                            x => x,
                        };
                    } else {
                        // If the piece moved...
                        board.pieces[index] = match board.pieces[index] {
                            Tile::Piece(mut piece) => {
                                piece.moved = true; // Set its flag to true

                                // If it is a pawn-like piece, fill in the en_passant field
                                if piece.can_kickstart() {
                                    if piece.white {
                                        if previous_board.get((x, y - 1)).is_empty() {
                                            board.set_en_passant(Some((x, y - 1)))
                                        }
                                    } else {
                                        if previous_board.get((x, y + 1)).is_empty() {
                                            board.set_en_passant(Some((x, y + 1)))
                                        }
                                    }
                                }

                                Tile::Piece(piece)
                            }
                            x => x,
                        };
                        state[index] = board.pieces[index];
                    }
                }

                (state, board.clone())
            },
            (initial_state, initial_board),
        );
    }

    return Some(res);
}

/** Deserializes a layer coordinate serialized as an `f32`-encoded number. **/
pub fn de_layer(raw: f32, even_timelines: bool) -> Layer {
    if even_timelines && raw < 0.0 {
        (raw.ceil() - 1.0) as Layer
    } else {
        raw.floor() as Layer
    }
}

/** Deserializes a piece serialized as a `usize`-encoded number.
    This list is based on `5dchess-notation`: https://github.com/adri326/5dchess-notation/blob/master/parsers/game.js#L12
**/
pub fn de_piece(raw: usize) -> Tile {
    Tile::Piece(match raw {
        1 => Piece::new(PieceKind::Pawn, true, true),
        2 => Piece::new(PieceKind::Knight, true, true),
        3 => Piece::new(PieceKind::Bishop, true, true),
        4 => Piece::new(PieceKind::Rook, true, true),
        5 => Piece::new(PieceKind::Queen, true, true),
        6 => Piece::new(PieceKind::King, true, true),
        7 => Piece::new(PieceKind::Unicorn, true, true),
        8 => Piece::new(PieceKind::Dragon, true, true),
        9 => Piece::new(PieceKind::Princess, true, true),
        10 => Piece::new(PieceKind::Brawn, true, true),
        11 => Piece::new(PieceKind::CommonKing, true, true),
        12 => Piece::new(PieceKind::RoyalQueen, true, true),

        33 => Piece::new(PieceKind::Pawn, false, true),
        34 => Piece::new(PieceKind::Knight, false, true),
        35 => Piece::new(PieceKind::Bishop, false, true),
        36 => Piece::new(PieceKind::Rook, false, true),
        37 => Piece::new(PieceKind::Queen, false, true),
        38 => Piece::new(PieceKind::King, false, true),
        39 => Piece::new(PieceKind::Unicorn, false, true),
        40 => Piece::new(PieceKind::Dragon, false, true),
        41 => Piece::new(PieceKind::Princess, false, true),
        42 => Piece::new(PieceKind::Brawn, false, true),
        43 => Piece::new(PieceKind::CommonKing, false, true),
        44 => Piece::new(PieceKind::RoyalQueen, false, true),

        _ => return Tile::Blank,
    })
}

/// This module should only be used for testing!
#[allow(dead_code)]
pub mod test {
    use super::*;
    use std::fs::File;
    use std::io::Read;

    pub fn read_and_parse(path: &str) -> Game {
        let file = File::open(path).ok();
        assert!(file.is_some(), "Couldn't open `{}`!", path);
        let mut contents = String::new();

        assert!(file.unwrap().read_to_string(&mut contents).is_ok(), "Couldn't read `{}`!", path);

        let res = parse(&contents);
        assert!(res.is_some(), "Couldn't parse `{}`!", path);
        res.unwrap()
    }

    pub fn read_and_parse_opt(path: &str) -> Option<Game> {
        let mut file = File::open(path).ok()?;
        let mut contents = String::new();

        file.read_to_string(&mut contents).ok()?;

        parse(&contents)
    }
}
